# 👁️ CV Processor — Компьютерное зрение в браузере

Модуль обработки видеопотока с помощью OpenCV.js для детекции горизонта, сетки пола и стен.

> **См. также:** [Motion Detector Guide](MOTION-DETECTOR-GUIDE.md) — детекция движения (absdiff, bounding boxes)

---

## 📚 Содержание

1. [Быстрый старт](#быстрый-старт)
2. [Архитектура](#архитектура)
3. [Алгоритм детекции горизонта](#алгоритм-детекции-горизонта)
4. [API Reference](#api-reference)
5. [Конфигурация](#конфигурация)
6. [Визуализация](#визуализация)
7. [Оптимизация](#оптимизация)

---

## Быстрый старт

### Установка OpenCV.js

OpenCV.js (~11MB) не включён в репозиторий. Скачай перед использованием:

```bash
# Windows (PowerShell)
Invoke-WebRequest -Uri "https://docs.opencv.org/4.x/opencv.js" -OutFile "data/opencv.js"

# Linux/macOS
curl -L "https://docs.opencv.org/4.x/opencv.js" -o data/opencv.js
```

### Подключение

```html
<!-- 1. OpenCV.js -->
<script async src="/opencv.js"></script>

<!-- 2. CV Processor -->
<script src="/cv-processor.js"></script>
```

### Использование

```javascript
// Создание процессора
const processor = new CVProcessor(
  document.getElementById('video'),   // <video> или <img>
  document.getElementById('overlay'), // <canvas> для отрисовки
  AppConfig.CV                        // опции из config.js
);

// Запуск (async!)
await processor.start();

// Остановка
processor.stop();

// Переключение
processor.toggle();

// Получение результатов
const { horizon, walls } = processor.lastResult;
```

---

## Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                     CVProcessor                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐              │
│  │  Video   │───►│  Capture │───►│  OpenCV  │              │
│  │  Source  │    │  Canvas  │    │  Process │              │
│  └──────────┘    └──────────┘    └────┬─────┘              │
│                                       │                     │
│                    ┌──────────────────┼───────────────┐     │
│                    │                  ▼               │     │
│                    │  ┌─────────────────────────┐    │     │
│                    │  │     _analyze()          │    │     │
│                    │  │  ┌───────────────────┐  │    │     │
│                    │  │  │ 1. Grayscale+Blur │  │    │     │
│                    │  │  │ 2. Canny edges    │  │    │     │
│                    │  │  │ 3. Hough lines    │  │    │     │
│                    │  │  │ 4. Classification │  │    │     │
│                    │  │  │ 5. Clustering     │  │    │     │
│                    │  │  └───────────────────┘  │    │     │
│                    │  └─────────────────────────┘    │     │
│                    │                  │               │     │
│                    │                  ▼               │     │
│                    │  ┌─────────────────────────┐    │     │
│                    │  │   { horizon, walls }    │    │     │
│                    │  └─────────────────────────┘    │     │
│                    │                                 │     │
│                    └─────────────────────────────────┘     │
│                                       │                     │
│                                       ▼                     │
│                              ┌──────────────┐               │
│                              │   Overlay    │               │
│                              │   Canvas     │               │
│                              └──────────────┘               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Композитор и слои

Scene (CVProcessor) и Motion (MotionDetector) работают через **единый Compositor** — один RAF-цикл и один overlay canvas `#compositor-overlay`:

```
#video-feed / #video-local    z-index: 1   (видео)
#compositor-overlay            z-index: 5   (Compositor — все слои Scene + Motion)
.osd-overlay                  z-index: 8   (OSD телеметрия)
.joysticks-overlay            z-index: 10  (джойстики)
```

#### Слои Scene (CVProcessor) — 6 штук:
| localIndex | Имя | Описание |
|------------|-----|----------|
| 0 | Grayscale | Серое изображение |
| 1 | Edges | Canny edges |
| 2 | Lines | Hough lines (раскрашенные по типу) |
| 3 | Horizon | Линия горизонта + сегменты |
| 4 | Grid | Перспективная сетка |
| 5 | Walls | Вертикальные линии (стены) |

#### AppState (SSOT)

Единый массив `AppState.layers` — порядок элементов = порядок отрисовки:

```js
{ processorId: 'scene', localIndex: 0, enabled: false, label: 'Gray' }
// ... ещё 5 записей Scene + 3 записи Motion
```

Тоггл слоя: `layers[i].enabled = !layers[i].enabled`. Solo: всем `false`, одному `true`.

### Поток данных

| Шаг | Описание |
|-----|----------|
| 1 | Compositor вызывает `processor.tick(now)` каждый RAF-кадр |
| 2 | Внутри tick: throttle по `processInterval`, захват кадра |
| 3 | Масштабирование до `processWidth × processHeight`, конвертация в `cv.Mat` |
| 4 | Обработка: edges → lines → clusters |
| 5 | Рендер каждого слоя в отдельный offscreen canvas |
| 6 | Compositor вызывает `getLayer(localIndex)` для enabled слоёв |
| 7 | `drawImage` на единый `#compositor-overlay` |
| 8 | Очистка памяти OpenCV (`.delete()`) |

---

## Алгоритм детекции горизонта

### Проблема

**"Взять самую длинную линию"** — ненадёжно:

```
Проблема 1: Горизонт разорван объектами
─────────────────────────────────────────
     🌳      🏠     🌳          🚗
  ───┬───  ──┬──  ───┬───    ──┬──     ← много коротких сегментов

Проблема 2: Горизонт может быть наклонен
─────────────────────────────────────────
  Если камера наклонена, горизонт не горизонтален!
         ╱
        ╱
       ╱   ← угол ≠ 0°

Проблема 3: Самая длинная линия ≠ горизонт
─────────────────────────────────────────
  ── ─── ────                       ← настоящий горизонт (разорван)
  
  ════════════════════════════════  ← край стола (длиннее!)
```

### Решение: Двухэтапная кластеризация

Каждая линия описывается двумя параметрами:

```
                      ┌───────────────────────────────────┐
                      │  Параметры прямой (Hesse normal)  │
                      ├───────────────────────────────────┤
                      │  θ (theta) — угол наклона         │
                      │  d — расстояние до начала коорд.  │
                      │                                   │
                      │  Уравнение:                       │
                      │  x·sin(θ) - y·cos(θ) = d          │
                      └───────────────────────────────────┘
```

**Ключевое свойство:** Все сегменты одной прямой имеют:
- Одинаковый угол θ (параллельны)
- Одинаковый параметр d (коллинеарны)

### Алгоритм

```
┌─────────────────────────────────────────────────────────────┐
│                    PIPELINE                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. EDGE DETECTION                                          │
│     ┌──────────┐    ┌──────────┐    ┌──────────┐           │
│     │ Grayscale│───►│  Blur    │───►│  Canny   │           │
│     └──────────┘    └──────────┘    └──────────┘           │
│                                           │                 │
│  2. LINE DETECTION                        ▼                 │
│                                    ┌──────────┐             │
│                                    │  Hough   │             │
│                                    │  Lines   │             │
│                                    └────┬─────┘             │
│                                         │                   │
│  3. CLASSIFICATION                      ▼                   │
│     ┌───────────────────────────────────────────┐          │
│     │  Для каждой линии:                        │          │
│     │    • angle = atan2(dy, dx)                │          │
│     │    • d = cx·sin(θ) - cy·cos(θ)            │          │
│     │    • length = sqrt(dx² + dy²)             │          │
│     │                                           │          │
│     │  Разделяем на:                            │          │
│     │    • horizontal (|angle| < 45°)           │          │
│     │    • vertical   (|angle - 90°| < 15°)     │          │
│     └───────────────────────────────────────────┘          │
│                          │                                  │
│  4. CLUSTERING           ▼                                  │
│     ┌───────────────────────────────────────────┐          │
│     │  ШАГ 1: Кластеризация по УГЛУ             │          │
│     │         (находим группы параллельных)      │          │
│     │                                           │          │
│     │  [═══] [═══] [═══]  ← угол ~0°            │          │
│     │    [╱] [╱] [╱]      ← угол ~15°           │          │
│     │      [╲] [╲]        ← угол ~-10°          │          │
│     └───────────────────────────────────────────┘          │
│                          │                                  │
│                          ▼                                  │
│     ┌───────────────────────────────────────────┐          │
│     │  ШАГ 2: Кластеризация по D                │          │
│     │         (находим коллинеарные)             │          │
│     │                                           │          │
│     │  Параллельные линии с близким d           │          │
│     │  лежат на ОДНОЙ прямой:                   │          │
│     │                                           │          │
│     │  ───────  ─────  ───────  (d ≈ 100)       │          │
│     │                                           │          │
│     │  ════════════════════════ (d ≈ 200)       │          │
│     └───────────────────────────────────────────┘          │
│                          │                                  │
│  5. SCORING              ▼                                  │
│     ┌───────────────────────────────────────────┐          │
│     │  score = totalLength × √segmentCount      │          │
│     │        × (0.7 + 0.3 × angleBonus)         │          │
│     │                                           │          │
│     │  angleBonus = 1 - |angle| / 45°           │          │
│     │  (горизонтальные линии получают бонус)    │          │
│     └───────────────────────────────────────────┘          │
│                          │                                  │
│  6. WEIGHTED MEDIAN      ▼                                  │
│     ┌───────────────────────────────────────────┐          │
│     │  Финальная линия строится по МЕДИАНЕ      │          │
│     │  с весами = длина сегмента                │          │
│     │                                           │          │
│     │  medianAngle = weightedMedian(angles)     │          │
│     │  medianD = weightedMedian(d_values)       │          │
│     │                                           │          │
│     │  → Устойчивость к выбросам!               │          │
│     └───────────────────────────────────────────┘          │
│                          │                                  │
│  7. TEMPORAL SMOOTHING   ▼                                  │
│     ┌───────────────────────────────────────────┐          │
│     │  Медианный фильтр по N кадрам             │          │
│     │  (убирает дрожание между кадрами)         │          │
│     └───────────────────────────────────────────┘          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Взвешенная медиана

Почему медиана, а не среднее?

```
Пример: 5 сегментов с углами [0°, 2°, 1°, 45°, -1°]
                              ↑       ↑
                         нормальные  выброс

Среднее = (0 + 2 + 1 + 45 + -1) / 5 = 9.4°  ← НЕПРАВИЛЬНО!
Медиана = 1°                                 ← ПРАВИЛЬНО!
```

Взвешенная медиана учитывает длину сегментов:
- Длинный сегмент (100px) с углом 0° важнее
- Короткий сегмент (10px) с углом 45° — скорее шум

---

## API Reference

### Конструктор

```javascript
new CVProcessor(videoElement, overlayCanvas, options)
```

| Параметр | Тип | Описание |
|----------|-----|----------|
| `videoElement` | `HTMLVideoElement \| HTMLImageElement` | Источник видео |
| `overlayCanvas` | `HTMLCanvasElement` | Canvas для отрисовки |
| `options` | `Object` | Настройки (см. [Конфигурация](#конфигурация)) |

### Методы

| Метод | Возврат | Описание |
|-------|---------|----------|
| `start()` | `Promise<boolean>` | Запуск обработки (ждёт OpenCV) |
| `stop()` | `void` | Остановка обработки |
| `toggle()` | `boolean` | Переключение вкл/выкл |
| `isRunning()` | `boolean` | Проверка состояния |
| `updateConfig(options)` | `void` | Обновление настроек |
| `toggleLayer(name, enabled?)` | `void` | Вкл/выкл слоя (horizon, grid, walls) |

### Compositor API (новое)

| Метод | Возврат | Описание |
|-------|---------|----------|
| `tick(now)` | `void` | Вызывается Compositor'ом каждый RAF. Throttle по `processInterval`. |
| `getLayer(localIndex)` | `HTMLCanvasElement \| null` | Offscreen canvas для слоя 0..5 |
| `CVProcessor.LAYER_COUNT` | `6` | Статическое свойство: число слоёв |

### Свойства

| Свойство | Тип | Описание |
|----------|-----|----------|
| `lastResult` | `Object` | Результат последней обработки |
| `config` | `Object` | Текущая конфигурация |
| `onProcess` | `Function` | Callback после обработки кадра |
| `onError` | `Function` | Callback при ошибке |

### Результат (lastResult)

```javascript
{
  horizon: {
    y: 120,           // Y-координата в центре экрана (px)
    angle: -2.5,      // Угол наклона (градусы)
    d: 85.3,          // Параметр прямой
    segments: [...],  // Массив сегментов кластера
    confidence: 0.85, // Уверенность (0..1)
    segmentCount: 7,  // Количество сегментов
    totalLength: 450  // Суммарная длина (px)
  },
  walls: [
    { x1, y1, x2, y2, angle, length },
    ...
  ],
  timestamp: 1699123456789
}
```

---

## Конфигурация

Настройки в `config.js` → `AppConfig.CV`:

```javascript
CV: {
  // ─────────────────────────────────────
  // 📐 Разрешение обработки
  // ─────────────────────────────────────
  processWidth: 640,      // Ширина (px)
  processHeight: 480,     // Высота (px)
  processInterval: 100,   // Интервал (мс) = 10 FPS

  // ─────────────────────────────────────
  // 👁️ Слои визуализации
  // ─────────────────────────────────────
  showHorizon: true,      // Линия горизонта
  showGrid: true,         // Перспективная сетка
  showWalls: true,        // Вертикальные линии

  // ─────────────────────────────────────
  // 🔍 Canny edge detection
  // ─────────────────────────────────────
  cannyLow: 50,           // Нижний порог
  cannyHigh: 150,         // Верхний порог

  // ─────────────────────────────────────
  // 📏 Hough line detection
  // ─────────────────────────────────────
  houghThreshold: 50,     // Минимум точек на линии
  houghMinLength: 50,     // Минимальная длина (px)
  houghMaxGap: 10,        // Максимальный разрыв (px)

  // ─────────────────────────────────────
  // 📐 Углы
  // ─────────────────────────────────────
  horizonMaxAngle: 45,       // Макс. наклон горизонта (°)
  wallAngleTolerance: 15,    // Допуск для стен (°)
  clusterAngleTolerance: 8,  // Допуск кластеризации (°)

  // ─────────────────────────────────────
  // 🎯 Кластеризация
  // ─────────────────────────────────────
  minClusterSegments: 1,  // Минимум сегментов
  smoothFrames: 5,        // Буфер сглаживания

  // ─────────────────────────────────────
  // 🎨 Цвета
  // ─────────────────────────────────────
  colors: {
    horizon: '#00FF00',
    grid: 'rgba(0, 255, 255, 0.4)',
    walls: '#FF6600'
  }
}
```

### Адаптивные параметры

Некоторые параметры автоматически масштабируются под разрешение:

| Параметр | Формула |
|----------|---------|
| `cannyLow` | `max(20, config × scale × 0.7)` |
| `cannyHigh` | `max(60, config × scale × 0.8)` |
| `houghMinLength` | `max(20, min(config, diagonal × 0.08))` |
| `houghThreshold` | `max(20, min(config, √area × 0.15))` |
| `clusterToleranceD` | `max(10, diagonal × 0.03)` |

Где:
- `scale = min(width/640, height/480)`
- `diagonal = √(width² + height²)`
- `area = width × height`

---

## Визуализация

### Горизонт

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  HORIZON 85% (7 seg) ∠-2.5°                                │
│  ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌│  ← пунктир (зелёный)
│  ████  ██████  ████████  ███                               │  ← сегменты (полупрозрачные)
│                                                             │
│                                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

- **Пунктирная линия** — финальный горизонт (яркость = confidence)
- **Толстые сегменты** — линии кластера (для отладки)
- **Метка** — confidence %, количество сегментов, угол

### Сетка пола

```
                    VP (точка схода)
                         •
                        ╱│╲
                       ╱ │ ╲
                      ╱  │  ╲
                     ╱   │   ╲
────────────────────╱────│────╲────────────  ← параллельно горизонту
                   ╱     │     ╲
──────────────────╱──────│──────╲──────────
                 ╱       │       ╲
────────────────╱────────│────────╲────────
               ╱         │         ╲
```

- Линии сходятся к точке схода (центр горизонта)
- Горизонтальные линии параллельны горизонту (учитывают наклон!)
- Нелинейное распределение: ближе к горизонту — плотнее

### Стены

```
     │           │              │
     │           │              │
     │           │              │
     │           │              │
     │           │              │

  (оранжевые вертикальные линии)
```

---

## Оптимизация

### Разрешение

| Разрешение | FPS* | Точность | Рекомендация |
|------------|------|----------|--------------|
| 320×240 | ~30 | Низкая | Слабые устройства |
| 640×480 | ~15 | Средняя | **Рекомендуется** |
| 1280×720 | ~5 | Высокая | Мощные устройства |

*FPS зависит от устройства и сложности сцены

### Память

**КРИТИЧНО!** OpenCV.js не имеет garbage collection для `cv.Mat`:

```javascript
// ВСЕГДА используй try/finally
const gray = new cv.Mat();
const edges = new cv.Mat();

try {
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, edges, 50, 150);
  // ...
} finally {
  gray.delete();   // ОБЯЗАТЕЛЬНО!
  edges.delete();  // ОБЯЗАТЕЛЬНО!
}
```

### Throttling

Обработка ограничена `processInterval` (по умолчанию 100ms = 10 FPS):

```javascript
// Увеличить FPS (больше нагрузка)
processor.updateConfig({ processInterval: 50 });  // 20 FPS

// Уменьшить FPS (экономия батареи)
processor.updateConfig({ processInterval: 200 }); // 5 FPS
```

---

## Отладка

### Консоль

```javascript
// Включить отладку
processor.onProcess = (result) => {
  console.log('Horizon:', result.horizon);
  console.log('Walls:', result.walls.length);
};

// Отследить ошибки
processor.onError = (msg) => {
  console.error('CV Error:', msg);
};
```

### Визуализация сегментов

Сегменты кластера отображаются полупрозрачными линиями — это помогает понять, какие линии были объединены.

### Проверка параметров

```javascript
// В консоли браузера
console.log(window.cvProcessor?.lastResult);
console.log(window.cvProcessor?.config);
```

---

## Полезные ссылки

- [OpenCV.js Tutorials](https://docs.opencv.org/4.x/d5/d10/tutorial_js_root.html)
- [Hough Line Transform](https://docs.opencv.org/4.x/d9/db0/tutorial_hough_lines.html)
- [Canny Edge Detection](https://docs.opencv.org/4.x/da/d22/tutorial_py_canny.html)
- [Hesse Normal Form](https://en.wikipedia.org/wiki/Hesse_normal_form)
- [Motion Detector Guide](MOTION-DETECTOR-GUIDE.md) — детекция движения в этом проекте
